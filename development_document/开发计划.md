# MRI预处理项目重构开发计划

## 项目目标

重构MDL-Net preprocessing_pipeline项目，融合mri_preprocessing的优秀架构模式和MDL-Net的先进技术栈，构建一个配置驱动的医学图像预处理管道。

## 技术栈选择

### 图像处理技术栈（跟随MDL-Net）
- ANTsPy: 医学图像配准和处理
- ANTsPyNet: 深度学习增强的医学图像处理
- SimpleITK: 医学图像读写
- NumPy: 数据处理

### 工程架构技术栈（跟随mri_preprocessing）
- 配置驱动: YAML配置文件（比JSON更灵活）
- 设计模式: BaseProcessor + Pipeline + 统一数据容器
- 日志系统: Python logging
- 错误处理: 统一异常处理机制

## 核心架构设计

### 目录结构
```
MRIPreprocess/
├── config/
│   ├── pipeline_config.yaml          # 主配置文件
│   └── templates/                     # 配准模板
├── src/
│   ├── preprocessing/                 # 预处理步骤
│   │   ├── base_processor.py         # 抽象基类
│   │   ├── processing_data.py        # 统一数据容器
│   │   ├── skull_stripping.py        # 颅骨剥离
│   │   ├── registration.py           # 配准
│   │   ├── segmentation.py           # 分割
│   │   ├── roi_extraction.py         # ROI提取
│   │   └── quality_control.py        # 质量控制
│   ├── utils/                        # 工具模块
│   │   ├── image_loading.py          # 图像加载
│   │   ├── image_saving.py           # 图像保存
│   │   ├── file_manager.py           # 文件管理
│   │   └── logger.py                 # 日志系统
│   ├── pipeline.py                   # 主管道类
│   └── mdlnet_converter.py           # MDL-Net格式转换
├── scripts/
│   ├── process_single_subject.py     # 单样本处理
│   └── batch_process.py              # 批量处理
├── main.py                           # 统一入口
└── requirements.txt                  # 依赖列表
```

## 数据传递架构

### 统一数据容器设计
```python
class ProcessingData:
    """医学图像预处理数据容器"""
    
    def __init__(self, primary_image, subject_id: str):
        # 基本信息
        self.subject_id = subject_id
        self.primary_image = primary_image      # 当前主要图像（流水线传递）
        self.original_image = primary_image     # 原始图像（永不改变）
        
        # 处理结果
        self.brain_mask = None                  # 脑掩膜
        self.registered_image = None            # 配准后图像
        self.transform_matrix = None            # 变换矩阵
        
        # 分割结果
        self.segmentation_labels = None         # 分割标签图
        self.gm_probability = None              # 灰质概率图
        self.wm_probability = None              # 白质概率图
        self.csf_probability = None             # 脑脊液概率图
        
        # 特征和质控
        self.roi_features = None                # ROI特征向量
        self.qc_metrics = {}                    # 质量控制指标
        
        # 处理历史
        self.processing_steps = []              # 处理步骤记录
    
    def update_primary(self, new_image, step_name: str):
        """更新主要图像并记录处理步骤"""
        self.primary_image = new_image
        self.processing_steps.append(step_name)
```

### 处理器分类策略

#### 使用BaseProcessor的处理器（简单、单输出）
- 颅骨剥离：ANTs Image → ANTs Image
- 去噪：ANTs Image → ANTs Image  
- 标准化：ANTs Image → ANTs Image

#### 独立实现的处理器（复杂、多输出）
- 配准：输出图像+变换矩阵
- 分割：输出多个概率图
- ROI提取：输出特征向量
- 质量控制：输出报告和指标

## 处理步骤详细规范

### 1. 颅骨剥离 (Skull Stripping)
**实现方式**: 继承BaseProcessor

**输入数据**:
```python
data.primary_image: ANTs Image (原始T1 MRI)
```

**输出数据**:
```python
data.primary_image: ANTs Image (脑组织图像)
data.brain_mask: ANTs Image (脑掩膜)
```

**算法选择**:
- antspynet: 使用ANTsPyNet深度学习模型
- ants: 使用ANTs传统算法

**示例代码**:
```python
class SkullStripping(BaseProcessor):
    def __init__(self, config):
        super().__init__(config)
        self.methods = {
            "antspynet": self.antspynet_extraction,
            "ants": self.ants_extraction,
        }
    
    def run(self, data: ProcessingData) -> ProcessingData:
        return self.run_methods(data, suffix="skull_stripped")
    
    def antspynet_extraction(self, data, config, metadata):
        brain_mask = antspynet.brain_extraction(data.primary_image)
        brain_image = data.primary_image * brain_mask
        
        data.update_primary(brain_image, "skull_stripping")
        data.brain_mask = brain_mask
        return data
```

### 2. 配准 (Registration)
**实现方式**: 独立实现（复杂多输出）

**输入数据**:
```python
data.primary_image: ANTs Image (脑组织图像)
```

**输出数据**:
```python
data.primary_image: ANTs Image (配准到MNI的图像)
data.registered_image: ANTs Image (配准后图像)
data.transform_matrix: ANTs Transform (变换矩阵)
```

**算法选择**:
- syn: SyN非线性配准
- affine: 仿射配准
- rigid: 刚体配准

**示例代码**:
```python
class Registration:
    def __init__(self, config):
        self.config = config
        self.template_path = config['template']
    
    def run(self, data: ProcessingData) -> ProcessingData:
        template = ants.image_read(self.template_path)
        
        # 执行配准
        result = ants.registration(
            fixed=template,
            moving=data.primary_image,
            type_of_transform='SyN'
        )
        
        # 更新数据容器
        data.update_primary(result['warpedmovout'], "registration")
        data.registered_image = result['warpedmovout']
        data.transform_matrix = result['fwdtransforms']
        
        return data
```

### 3. 组织分割 (Segmentation)
**实现方式**: 独立实现（多输出）

**输入数据**:
```python
data.primary_image: ANTs Image (配准后图像)
```

**输出数据**:
```python
data.segmentation_labels: ANTs Image (分割标签图)
data.gm_probability: ANTs Image (灰质概率图)
data.wm_probability: ANTs Image (白质概率图)
data.csf_probability: ANTs Image (脑脊液概率图)
```

**算法选择**:
- atropos: ANTs Atropos分割
- fast: FSL FAST分割

**示例代码**:
```python
class Segmentation:
    def run(self, data: ProcessingData) -> ProcessingData:
        # 使用Atropos进行3类分割
        seg_result = ants.atropos(
            a=data.primary_image,
            m='[0.2,1x1x1]',
            c='[3,0.0]',
            i='kmeans[3]',
            x=data.brain_mask
        )
        
        # 更新数据容器
        data.segmentation_labels = seg_result['segmentation']
        data.csf_probability = seg_result['probabilityimages'][0]
        data.gm_probability = seg_result['probabilityimages'][1]
        data.wm_probability = seg_result['probabilityimages'][2]
        
        return data
```

### 4. ROI特征提取 (ROI Extraction)
**实现方式**: 独立实现（类型转换）

**输入数据**:
```python
data.gm_probability: ANTs Image (灰质概率图)
data.wm_probability: ANTs Image (白质概率图)
data.registered_image: ANTs Image (配准后图像，作为参考)
```

**输出数据**:
```python
data.roi_features: Dict[str, np.ndarray] (ROI特征字典)
# 格式: {"gm_features": array([...]), "wm_features": array([...])}
```

**模板选择**:
- AAL90: 90个脑区
- AAL116: 116个脑区
- Brodmann: 82个脑区

**示例代码**:
```python
class ROIExtraction:
    def run(self, data: ProcessingData) -> ProcessingData:
        atlas = ants.image_read(self.config['atlas_path'])
        
        # 提取GM ROI特征
        gm_features = []
        for roi_id in range(1, 91):  # AAL90
            roi_mask = atlas == roi_id
            roi_values = data.gm_probability[roi_mask]
            gm_features.append(np.mean(roi_values))
        
        # 提取WM ROI特征
        wm_features = []
        for roi_id in range(1, 91):
            roi_mask = atlas == roi_id
            roi_values = data.wm_probability[roi_mask]
            wm_features.append(np.mean(roi_values))
        
        data.roi_features = {
            "gm_features": np.array(gm_features),
            "wm_features": np.array(wm_features)
        }
        
        return data
```

### 5. 质量控制 (Quality Control)
**实现方式**: 独立实现（报告生成）

**输入数据**:
```python
data.original_image: ANTs Image (原始图像)
data.primary_image: ANTs Image (当前处理图像)
data.brain_mask: ANTs Image (脑掩膜)
data.registered_image: ANTs Image (配准后图像)
```

**输出数据**:
```python
data.qc_metrics: Dict (质量控制指标)
# 格式: {"snr": 15.2, "cnr": 8.5, "registration_quality": 0.85}
```

**质量指标**:
- SNR: 信噪比
- CNR: 对比噪声比
- 配准质量: 互信息/相关系数
- 分割质量: Dice系数

**示例代码**:
```python
class QualityControl:
    def run(self, data: ProcessingData) -> ProcessingData:
        # 计算SNR
        brain_signal = np.mean(data.primary_image[data.brain_mask > 0])
        background_noise = np.std(data.original_image[data.brain_mask == 0])
        snr = brain_signal / background_noise
        
        # 计算配准质量
        template = ants.image_read(self.template_path)
        mi = ants.image_mutual_information(data.registered_image, template)
        
        data.qc_metrics = {
            "snr": snr,
            "registration_mi": mi,
            "processing_steps": data.processing_steps.copy()
        }
        
        return data
```

## Pipeline编排器设计

### 统一调度接口
```python
class PreprocessingPipeline:
    def __init__(self, config_path: str):
        self.config = self._load_yaml_config(config_path)
        
        # 混合处理器注册
        self.processors = {
            # 使用BaseProcessor的
            "skull_stripping": SkullStripping(self.config['skull_stripping']),
            
            # 独立实现的
            "registration": Registration(self.config['registration']),
            "segmentation": Segmentation(self.config['segmentation']),
            "roi_extraction": ROIExtraction(self.config['roi_extraction']),
            "quality_control": QualityControl(self.config['quality_control']),
        }
    
    def run(self, subject_id: str, mri_path: str) -> ProcessingData:
        # 初始化数据容器
        original_image = ants.image_read(mri_path)
        data = ProcessingData(original_image, subject_id)
        
        # 按配置顺序执行处理步骤
        for step_name, processor in self.processors.items():
            if self.config[step_name]['enabled']:
                print(f"Executing: {step_name}")
                data = processor.run(data)
        
        return data
```

## 开发阶段规划
1. 创建BaseProcessor抽象基类
   - 实现通用的配置解析逻辑
   - 实现通用的方法调度机制
   - 实现通用的结果保存逻辑

2. 创建Pipeline管道编排器
   - 实现YAML配置加载
   - 实现工厂模式的处理器创建
   - 实现责任链式的步骤执行

3. 创建工具模块
   - 日志系统：统一的日志格式和输出
   - 文件管理：输出目录创建和管理
   - 图像加载/保存：支持NIfTI格式

### 第二阶段：核心功能（3-4天）
1. 实现SkullStripping处理器
   - 继承BaseProcessor
   - 集成ANTsPyNet的脑提取模型
   - 支持多种脑提取算法

2. 实现Registration处理器
   - 继承BaseProcessor
   - 实现ANTs的SyN、Affine、Rigid配准
   - 支持配准质量评估

3. 实现Segmentation处理器
   - 继承BaseProcessor
   - 实现ANTs Atropos分割
   - 生成GM/WM/CSF概率图和二值掩膜

4. 实现ROIExtraction处理器
   - 继承BaseProcessor
   - 支持AAL90/AAL116/Brodmann模板
   - 提取多模态ROI特征

5. 实现QualityControl处理器
   - 继承BaseProcessor
   - 实现图像质量评估
   - 生成QC报告

### 第三阶段：MDL-Net对接（1-2天）
1. 实现MDLNetConverter
   - 格式转换：NIfTI到PyTorch tensor
   - 数据标准化：MinMax/Z-score
   - 批量转换：支持批量数据生成

2. 集成测试
   - 端到端测试：从原始数据到MDL-Net格式
   - 质量验证：确保数据质量

### 第四阶段：脚本和优化（1天）
1. 实现执行脚本
   - process_single_subject.py：单样本处理脚本
   - batch_process.py：批量处理脚本
   - main.py：统一命令行入口

2. 性能优化
   - 并行处理：多进程支持
   - 内存优化：大图像处理优化
   - 错误处理：完善的异常处理机制

## 配置文件设计

### 主配置文件结构
```yaml
# 通用配置
general:
  version: "1.0.0"
  save_intermediates: true
  parallel_workers: 4

# 处理步骤配置
skull_stripping:
  enabled: true
  methods:
    antspynet: 
      enabled: true
      model: "t1v1"
    ants:
      enabled: false

registration:
  enabled: true
  template: "config/templates/MNI152_T1_1mm.nii.gz"
  methods:
    syn:
      enabled: true
      grad_step: 0.1
    affine:
      enabled: false

# 输出配置
output:
  base_dir: "output/"
  save_transforms: true
  save_probability_maps: true
```

## 关键技术实现

### 1. 配置驱动的方法调度
- 通过YAML配置控制算法选择
- 支持算法参数动态配置
- 支持算法组合使用

### 2. 统一的错误处理
- BaseProcessor中实现统一异常捕获
- Pipeline中实现错误恢复机制
- 详细的错误日志记录

### 3. 灵活的结果保存
- 根据配置决定保存哪些中间结果
- 统一的文件命名规范
- 支持不同保存模式（开发/生产/最小）

### 4. 质量控制集成
- 每个处理步骤都有质量评估
- 自动生成QC报告
- 支持质量阈值配置

## 验收标准

1. 架构完整性
   - 所有处理器都继承BaseProcessor
   - Pipeline能够正确编排所有步骤
   - 配置文件能够完全控制处理流程

2. 功能完整性
   - 支持从T1 MRI到MDL-Net格式的完整转换
   - 支持多种配准和分割算法
   - 支持多种脑区模板

3. 代码质量
   - 代码复用率高（通过BaseProcessor实现）
   - 错误处理完善
   - 日志记录详细

4. 易用性
   - 命令行接口简单易用
   - 配置文件清晰易懂
   - 文档完整

## 风险评估

### 技术风险
- ANTsPy安装复杂：准备Docker环境作为备选
- 内存占用大：实现分块处理机制

### 进度风险
- 配准算法调试耗时：复用MDL-Net已验证的参数
- 质量控制标准不明确：参考文献建立标准

## 总结

本项目通过融合两个优秀项目的优势，构建一个既有先进技术栈又有优秀架构的医学图像预处理系统。重点是代码复用和配置驱动，确保系统的可维护性和可扩展性。

## 开发阶段规划

### 第一阶段：基础架构（2-3天）
1. 创建ProcessingData数据容器
   - 定义所有必要的数据字段
   - 实现update_primary方法
   - 添加数据访问和验证方法

2. 完善BaseProcessor抽象基类
   - 适配ProcessingData容器
   - 修改类型检查逻辑
   - 实现统一的保存机制

3. 创建Pipeline管道编排器
   - 实现YAML配置加载
   - 实现混合处理器调度
   - 实现统一的错误处理

4. 创建工具模块
   - 日志系统：统一的日志格式和输出
   - 文件管理：输出目录创建和管理
   - 图像加载/保存：支持NIfTI格式

### 第二阶段：核心功能（3-4天）
1. 实现SkullStripping处理器（继承BaseProcessor）
   - 集成ANTsPyNet的脑提取模型
   - 支持多种脑提取算法
   - 实现脑掩膜生成和保存

2. 实现Registration处理器（独立实现）
   - 实现ANTs的SyN、Affine、Rigid配准
   - 支持配准质量评估
   - 实现变换矩阵保存和传递

3. 实现Segmentation处理器（独立实现）
   - 实现ANTs Atropos分割
   - 生成GM/WM/CSF概率图和二值掩膜
   - 支持多类别组织分割

4. 实现ROIExtraction处理器（独立实现）
   - 支持AAL90/AAL116/Brodmann模板
   - 提取多模态ROI特征
   - 实现特征向量生成

5. 实现QualityControl处理器（独立实现）
   - 实现图像质量评估
   - 生成QC报告和指标
   - 支持多阶段质量对比

### 第三阶段：MDL-Net对接（1-2天）
1. 实现MDLNetConverter
   - 格式转换：ProcessingData到PyTorch tensor
   - 数据标准化：MinMax/Z-score
   - 批量转换：支持批量数据生成

2. 集成测试
   - 端到端测试：从原始数据到MDL-Net格式
   - 质量验证：确保数据质量和格式正确

### 第四阶段：脚本和优化（1天）
1. 实现执行脚本
   - process_single_subject.py：单样本处理脚本
   - batch_process.py：批量处理脚本
   - main.py：统一命令行入口

2. 性能优化
   - 并行处理：多进程支持
   - 内存优化：大图像处理优化
   - 错误处理：完善的异常处理机制

## 配置文件设计

### 主配置文件结构
```yaml
# 通用配置
general:
  version: "1.0.0"
  save_intermediate: true
  parallel_workers: 4

# 处理步骤配置
skull_stripping:
  enabled: true
  methods:
    antspynet: 
      enabled: true
      model: "t1v1"
    ants:
      enabled: false

registration:
  enabled: true
  template: "config/templates/MNI152_T1_1mm.nii.gz"
  methods:
    syn:
      enabled: true
      grad_step: 0.1
    affine:
      enabled: false

# 输出配置
output:
  base_dir: "output/"
  save_transforms: true
  save_probability_maps: true
```

## 验收标准

1. 架构完整性
   - ProcessingData容器正确传递所有数据
   - Pipeline能够正确编排混合处理器
   - 配置文件能够完全控制处理流程

2. 功能完整性
   - 支持从T1 MRI到MDL-Net格式的完整转换
   - 支持多种配准和分割算法
   - 支持多种脑区模板

3. 代码质量
   - 适合的处理器使用BaseProcessor实现代码复用
   - 复杂处理器独立实现保持灵活性
   - 错误处理完善，日志记录详细

4. 易用性
   - 命令行接口简单易用
   - 配置文件清晰易懂
   - 数据流向明确可追踪

## 总结

本项目采用统一数据容器(ProcessingData)和混合处理器架构，既保持了简单处理器的代码复用优势，又为复杂处理器提供了充分的实现自由度。通过primary_image和original_image的设计，支持流水线传递和回溯访问，满足医学图像处理的复杂需求。